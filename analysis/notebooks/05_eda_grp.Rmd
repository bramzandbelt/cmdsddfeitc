---
params:  
  title: "05_eda_grp"
  task: "defer_speedup"
title: '`r stringr::str_to_title(stringr::str_replace_all(params$title, pattern = "_", replacement = " "))`'
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  bookdown::html_document2:
    toc: true
    toc_float: true
    number_sections: true
    fig_caption: true
    df_print: paged
    code_folding: hide
    theme: readable
    highlight: pygments
    bibliography: "cmdsddfeitc.bib"
    biblio-style: author-year
---

```{r setup, include=FALSE}
# Set root dir to project directory to ensure that code is always run relative to the project directory, no matter if it is run using `knitr` or interactively.
knitr::opts_knit$set(root.dir = rprojroot::find_root(rprojroot::has_file("DESCRIPTION")))
knitr::opts_knit$set(eval.after = 'fig.cap')

# Attach tideverse package to enable access to pipe (%>%)
require(tidyverse)

```

# Overview
This notebook contains exploratory data analyses, aimed at providing a more general impression of the dataset in terms of performance descriptives from the calibration task (estimated indifference points) and experimental task (choices and response times). Exploratory analyses motivated by the results from the registered analyses are in a different notebook.

# Preliminaries

Specification of:

```{r Define notebook name, based on YAML header}
notebook_name <- 
   stringr::str_to_lower(stringr::str_replace_all(params$title, " ", "_"))
```
- the _name of the notebook (`notebook_name`)_, which is used to save output to a notebook-specific directory

```{r Define relevant directories for reading and writing data and create whenever needed}
# Raw trial log files are read from here
preprocessed_included_data_dir <- 
  file.path("data","derivatives", "01_preprocessing", "included")

# Benchmark data from excluded and included datasets are read from here
preprocessed_data_dir <- 
  file.path("data","derivatives", "01_preprocessing")

# Choice percentage files are read from here
eda_participant_dir <- 
  file.path("data","derivatives", "02_exploratory_data_analysis")

# Derivatives will be written here
performance_descriptives_group_dir <- 
  file.path("data","derivatives", notebook_name)

# Figures will be written here
figures_dir <- 
  file.path("figures", notebook_name)
  
# Create non-existing dirs if they don't exist
cmdsddfeitc::check_dir(all_dirs = c(performance_descriptives_group_dir, figures_dir))
```
- all _relevant directories_ for reading and writing data

```{r File names}
# Determine which files should be read
expt_standard_trials_filenames <- 
  list.files(path = preprocessed_included_data_dir, 
             pattern = sprintf("^experiment_standard_trials_task-%s.*.csv$",
                               params$task[[1]])
             )

choice_pctgs_filenames <- 
  list.files(path = eda_participant_dir, 
             pattern = sprintf("^choice_percentages_task-%s.*.csv$",
                               params$task[[1]])
             )

calibration_ip_filenames <- 
  list.files(path = preprocessed_included_data_dir, 
             pattern = "^calibration_indifference_points.*.csv$"
             )
```
- the _filenames of the files containing data from experiment standard trials (`expt_standard_trials_filenames`)_

# Read data

Having specified all relevant variables, the cleaned standard trials from the experiment are read:
```{r Read trial_log data, warning=FALSE}
# Read (and print) the data, using task-dependent column specifications

expt_trials <- tibble::tibble()

for (i_file in 1:length(expt_standard_trials_filenames)) {
  expt_trials <- 
    dplyr::bind_rows(expt_trials,
                     readr::read_csv(file = file.path(preprocessed_included_data_dir, expt_standard_trials_filenames[[i_file]]),
                                     col_types = cmdsddfeitc::get_col_types(stringr::str_c("expt_standard_trials_",
                                                                                           params$task)))
                     )
}

# Choice percentages
choice_pctgs <- tibble::tibble()

for (i_file in 1:length(choice_pctgs_filenames)) {
  choice_pctgs <- 
    dplyr::bind_rows(choice_pctgs,
                     readr::read_csv(file = file.path(eda_participant_dir, choice_pctgs_filenames[[i_file]]),
                                     col_types = cmdsddfeitc::get_col_types(stringr::str_c("choice_percentages_",
                                                                                           params$task)))
                     )
    
    
}

# Estimated indifference points from the calibration task
calibration_ips <- tibble::tibble()

for (i_file in 1:length(calibration_ip_filenames)) {
  calibration_ips <- 
    dplyr::bind_rows(calibration_ips,
                     readr::read_csv(file = file.path(preprocessed_included_data_dir, calibration_ip_filenames[[i_file]]),
                                     col_types = cmdsddfeitc::get_col_types("calibration_indifference_points"))
                     )   
} 
```

# Preprocess data

- Indifference point data: filter data from `r stringr::str_replace(params$task, pattern = "_", replacement = "-")` task
- Choices: filter LL choices and only select relevant frames
-

```{r}

# Indifference points from the calibration task

# Indifference point files are not labeled by task; this is a way to keep only the data from the task currently being processed
pids <- dplyr::intersect(calibration_ips$subject_ix, unique(choice_pctgs$participant_id))

calibration_ips <- 
  calibration_ips %>%
  dplyr::filter(subject_ix %in% pids)


ll_choice_pctgs_for_plotting <- 
  choice_pctgs %>%
  dplyr::filter(choice == "ll") %>%
  dplyr::select(-n, -choice) %>%
  purrr::when(params$task == "defer_speedup" ~ 
                tidyr::spread(., key = frame, value = percentage) %>% 
                dplyr::select(-neutral),
              params$task == "date_delay" ~ 
                tidyr::spread(., key = frame, value = percentage)
              )

if (params$task == "defer_speedup") {
  ll_choice_pctgs_for_plotting <- 
    ll_choice_pctgs_for_plotting %>%
    dplyr::mutate(diff = speedup - defer)
} else if (params$task == "date_delay") {
  ll_choice_pctgs_for_plotting <- 
    ll_choice_pctgs_for_plotting %>%
    dplyr::mutate(diff = date - delay)
}


# Framing effect directions with respect to original effect
ll_choice_pctgs_for_plotting <- 
  ll_choice_pctgs_for_plotting %>%
  dplyr::mutate(direction = cut(diff, breaks = c(-Inf, 0, Inf), labels = c("incompatible", "compatible")))


md_rt_for_plotting <- 
  expt_trials %>%
  dplyr::mutate(participant_id = factor(subject_ix),
                m_s_cat = factor(m_s_cat, 
                                 labels = c("below", "at", "above"))) %>%
  dplyr::group_by(participant_id, frame, t_l, m_s_cat) %>%
  dplyr::summarize(md_rt = median(rt))

rt_dist_for_plotting <- 
  expt_trials %>%
  dplyr::mutate(participant_id = factor(subject_ix),
                m_s_cat = factor(m_s_cat, 
                                 labels = c("below", "at", "above"))) %>%
  dplyr::group_by(participant_id, frame) %>%
  dplyr::select(participant_id, frame, m_s_cat, dplyr::everything(), -subject_ix)

rt_diff_dist_for_plotting <- 
  rt_dist_for_plotting %>%
  dplyr::ungroup() %>%
  dplyr::group_by(participant_id, frame, m_s_cat, t_l) %>%
  dplyr::mutate(i_rep = 1:dplyr::n()) %>%
  tidyr::spread(key = frame, value = rt)
  
if (params$task == "defer_speedup") {
  rt_diff_dist_for_plotting_framing_effect <- 
    rt_diff_dist_for_plotting %>%
    # By dropping one of the three frame columns (which is not essential to establish the framing effect), we reduce the   number of rows that contain NA values and hence have to be dropped before we can compute RT difference
    dplyr::select(-neutral) %>%
    tidyr::drop_na() %>%
    dplyr::mutate(rt_diff = speedup - defer)
  
} else if (params$task == "date_delay") {
  rt_diff_dist_for_plotting_framing_effect <- 
    rt_diff_dist_for_plotting %>%
    # By dropping one of the three frame columns (which is not essential to establish the framing effect), we reduce the   number of rows that contain NA values and hence have to be dropped before we can compute RT difference
    tidyr::drop_na() %>%
    dplyr::mutate(rt_diff = date - delay)
}

```

# Analyze data

Data analysis consists of:

- checking whether the data are in line with framing effect


## Check whether the data are in line with original framing effect

First, check whether the framing effect data are approximately normally distributed, using a quantile-quantile (Q-Q) plot and an empirical cumulative distribution function (ECDF) of the framing effects.

```{r}

if (params$task == "defer_speedup") {
  ll_choice_pctgs_for_plotting <- 
    ll_choice_pctgs_for_plotting %>%
    dplyr::mutate(diff = speedup - defer)
} else if (params$task == "date_delay") {
  ll_choice_pctgs_for_plotting <- 
    ll_choice_pctgs_for_plotting %>%
    dplyr::mutate(diff = date - delay)
}

# Now look at QQ plot of the data to see if approximately normal
plt_qq <- 
  ggplot2::ggplot(data = ll_choice_pctgs_for_plotting,
                  mapping = ggplot2::aes(sample = diff)) +
  ggplot2::stat_qq() +
  ggplot2::stat_qq_line() +
  ggplot2::coord_equal() +
  ggplot2::theme(aspect.ratio = 1)

# Estimate mean and sd of normal
ecdf_params <- as.list(MASS::fitdistr(ll_choice_pctgs_for_plotting$diff, "normal")$estimate)

# Also plot a ECDF
plt_ecdf <- 
  ggplot2::ggplot(data = ll_choice_pctgs_for_plotting,
                  mapping = ggplot2::aes(x = diff)) +
  ggplot2::stat_ecdf() +
  ggplot2::stat_function(fun = pnorm, colour="red", args = list(mean = ecdf_params$mean, sd = ecdf_params$sd)) +
  ggplot2::coord_equal() +
  ggplot2::theme(aspect.ratio = 1)
```

The data do not appear to be distributed normally, so I used nonparametric testing.

We 

Jonas LindelÃ¸v has pointed out that non-parametric models, such as the Wilcoxon signed rank test



```{r}
normal_test_data <- data.frame(x = rnorm(n = 1000, mean = 0))

ggplot2::ggplot(data = normal_test_data,
                mapping = ggplot2::aes(sample = x)) +
  ggplot2::stat_qq() + 
  ggplot2::geom_abline(slope = 1, intercept = 0, color = "blue")
```




```{r}
# Different transformations can be applied to make data normal
transform_data <- function(p, transformation = "logit") { 

  # Adjust values close to 0 or 1 to prevent that transformation returns Inf
  if (transformation == "logit") {
    log(p) / (1 - p) 
  } else if (transformation == "log") {
    log(p)
  } else if (transformation == "sqrt") {
    sqrt(p)
  } else if (transformation == "reciprocal") {
    1 / p
  }
}

trnsfrmd_ll_choice_pctgs_for_plotting <- 
  ll_choice_pctgs_for_plotting %>%
  dplyr::mutate(diff_reciprocal = transform_data(p = diff, transformation = "reciprocal"))
```

```{r}
shapiro.test(trnsfrmd_ll_choice_pctgs_for_plotting$diff_reciprocal)
```


```{r}
# Jonas LindelÃ¸v's approach using brms model

signed_rank = function(x) sign(x) * rank(abs(x))


my_data <- data.frame(framing_effect = ll_choice_pctgs_for_plotting$diff)
  
priors_intercept = c(brms::set_prior('cauchy(0, 0.55)', class = 'Intercept'))  # JZS prior as the BayesFactor package, though without the Jeffreys prior on Sigma for simplicity.
  

JZS_prior <- 
  c(brms::set_prior('cauchy(0, 0.55)', class = 'Intercept'),
    brms::set_prior("target += -2*log(sigma)", check = FALSE)) # see: https://twitter.com/ianhussey/status/882961318050967557


full_brms <- 
  brms::brm(signed_rank(framing_effect) ~ 1, 
            data = my_data, 
            prior = JZS_prior,
            # prior = priors_intercept, 
            save_all_pars = TRUE, 
            iter=100000)
null_brms <-  
  brms::brm(signed_rank(framing_effect) ~ 0, 
            data = my_data, 
            save_all_pars = TRUE, 
            iter = 100000)
```

```{r}
BF_brms_bridge = bayes_factor(full_brms, null_brms)
BF_brms_bridge$bf
```

Test correctness of this approach by comparing against BayesFactor package example of one-sample t-test
```{r}

# diffScores = sleep$extra[1:10] - sleep$extra[11:20]
# 
# my_data <- data.frame(diffScores = diffScores)

my_data <- data.frame(framing_effect = ll_choice_pctgs_for_plotting$diff)
```



Using BIC 
```{r}
full_lm = lm(signed_rank(framing_effect) ~ 1, my_data)  # One mean with gauss residual
null_lm = lm(signed_rank(framing_effect) ~ 0, my_data)  # Fixed mean at score = 0
BF_BIC = exp((BIC(null_lm) - BIC(full_lm))/2)  # From BICs to Bayes factor
BF_BIC
```

Using BayesFactor
```{r}
bf = BayesFactor::ttestBF(x = signed_rank(my_data$framing_effect))
bf
```

Using brms
```{r}
my_prior <- 
  c(brms::set_prior('cauchy(0, 0.55)', class = 'Intercept'))

full_brms <- 
  brms::brm(signed_rank(framing_effect) ~ 1, 
            data = my_data, 
            prior = my_prior,
            save_all_pars = TRUE, 
            iter=10000)
null_brms <-  
  brms::brm(signed_rank(framing_effect) ~ 0, 
            data = my_data, 
            save_all_pars = TRUE, 
            iter = 10000)
```

Inspect models
```{r Inspect full model}
summary(full_brms)
plot(full_brms, N = 2, ask = FALSE)
```

```{r Inspect null model}
summary(null_brms)
plot(null_brms, N = 2, ask = FALSE)
```

Do Bayesian model comparison using bridge sampling to obtain Bayes Factors.
```{r}
BF_brms_bridge = brms::bayes_factor(full_brms, null_brms)
BF_brms_bridge$bf
```




Posterior predictive check
```{r}
# brms::pp_check(full_brms)
brms::pp_check(full_brms, type = "stat_2d")
```




```{r}
# # JZS prior
# my_prior <- 
#   c(brms::set_prior('cauchy(0, 0.707)', class = 'Intercept'),
#     brms::set_prior("target += -2*log(sigma)", check = FALSE)) # see: https://twitter.com/ianhussey/status/882961318050967557


```

```{r}
BF_brms_bridge = brms::bayes_factor(full_brms, null_brms)
BF_brms_bridge$bf
```


Do a Bayesian version of the Wilcoxon signed rank test on the P(LL) data to test for framing effects

```{r}
source("./opt/IDP_R/isignrank.test.R")

if (params$task == "defer_speedup") {
  x = ll_choice_pctgs_for_plotting$defer
  y = ll_choice_pctgs_for_plotting$speedup
} else if (params$task == "date_delay") {
  x = ll_choice_pctgs_for_plotting$delay
  y = ll_choice_pctgs_for_plotting$date
}

isignrank.test(x,y, "greater", paired=TRUE)
```


# Visualize data

## Estimated indifference points from the calibration task
```{r figip, fig.cap=cap_ip}

plt_ips_calibration <- plot_ips_calibration(tibb = calibration_ips)

# Show plot
plt_ips_calibration

cap_ip <- ""
```

## Proportion of LL choices across frames
```{r figllchoices, fig.cap=cap_ll_choices}

plt_ll_choice_pctgs <- 
  plot_ll_choice_pctgs(tibb = ll_choice_pctgs_for_plotting,
                       task = params$task)
# Show plot
plt_ll_choice_pctgs

cap_ll_choices <- ""
```


## Response time distributions

```{r figrtpercentiles, fig.cap=cap_rt_percentiles}



p <- c(0.1, 0.3, 0.5, 0.7, 0.9)
  
# Make percentile names
p_names <- purrr::map_chr(p, ~paste0(.x*100, "%"))

# Make percentile computation function
p_funs <-
  purrr::map(p, ~purrr::partial(quantile, probs = .x, na.rm = TRUE)) %>% 
  purrr::set_names(nm = p_names)

# Compute percentiles
rt_dist_for_plotting_grpd <- 
  rt_dist_for_plotting %>%
  dplyr::group_by(participant_id, frame) %>%
  dplyr::summarize_at(vars(rt), dplyr::funs(!!!p_funs)) %>%
  tidyr::gather(key = percentile, value = rt, -c(participant_id, frame)) %>%
  tidyr::spread(key = frame, value = rt)

# Show plot
plt_rt_percentiles <- 
  plot_rt_percentiles(tibb = rt_dist_for_plotting_grpd,
                    task = params$task)

plt_rt_percentiles

cap_rt_percentiles <- "Response time percentiles for choices in the %s and %s framing context. Axes span the range of valid response times."
```



```{r figrtdists, fig.cap=cap_rt_dists}
# Order participants by median RT (collapsed across frames)
pid_order <- 
  rt_dist_for_plotting %>%
  # Override existing grouping
  dplyr::group_by(participant_id) %>%
  dplyr::summarize(md_rt = median(rt)) %>%
  dplyr::arrange(md_rt) %>%
  dplyr::pull(participant_id)


if (params$task == "defer_speedup") {
  clrs <- c("grey", "red", "blue")
} else if (params$task == "date_delay") {
  clrs <- c("grey", "blue")
}

# Plot
plt_rt_density_ridges <- 
  ggplot2::ggplot(rt_dist_for_plotting %>% 
                    dplyr::ungroup() %>%
                    dplyr::mutate(participant_id = factor(participant_id, levels = pid_order, ordered = TRUE)) %>%
                    dplyr::group_by(participant_id, frame),
                  mapping = ggplot2::aes(x = rt,
                                         y = participant_id,
                                         fill = frame)
                  ) +
  
  # Geoms
  ggridges::geom_density_ridges(alpha = 0.25,
                                color = "black",
                                size = .1) +
  
  # Scales
  ggplot2::scale_x_continuous(name = "Response time (s)",
                              limits = c(0,10),
                              breaks = seq(0,10,5)) +
  ggplot2::scale_y_discrete(name = "Participants (RT ordered)",
                            breaks = NULL) +
  ggplot2::scale_fill_manual(values = clrs) +
  
  # Themes
  cmdsddfeitc::theme_cmfsddfeitc() +
  ggplot2::theme(aspect.ratio = 2,
                 panel.background = ggplot2::element_rect(fill = "white"))

# Show plot
plt_rt_density_ridges

cap_rt_dists <- ""
```

# Write data

## Derived data

Indifference points
```{r Write indifference points of the calibration task to disk}

# Make file name human- and machine-readable, so that main results can be read from file name
calibration_ips_file <- 
  file.path(performance_descriptives_group_dir,
            sprintf("calibration_ips_task-%s.csv",
                    params$task
                    )
            )

readr::write_csv(calibration_ips,
                 path = calibration_ips_file
            ) %>%
  print(sprintf("%s", calibration_ips_file))
```

LL choice percentages
```{r Write LL choice percentages to disk}

# Make file name human- and machine-readable, so that main results can be read from file name
ll_choice_pctgs_grp_file <-
  file.path(performance_descriptives_group_dir,
            sprintf("ll_choice_percentages_task-%s.csv",
                    params$task
                    )
            )
  
readr::write_csv(ll_choice_pctgs_for_plotting,
                 path = ll_choice_pctgs_grp_file
            ) %>%
print(sprintf("%s", ll_choice_pctgs_grp_file))
```

RT percentiles

```{r Write RT percentiles to disk}

# Make file name human- and machine-readable, so that main results can be read from file name
rt_percentiles_file <-
  file.path(performance_descriptives_group_dir,
            sprintf("rt_percentiles_task-%s.csv",
                    params$task
                    )
            )
  
readr::write_csv(rt_dist_for_plotting_grpd,
                 path = rt_percentiles_file
            ) %>%
print(sprintf("%s", rt_percentiles_file))
```

## Figures

```{r Parameters for writing plots to disk}
# General parameters ===========================================================

# Resolution
dpi <- 300
```

## Estimated indifference points from the calibration task

```{r Write plot of estimated indifference points from the calibration task to disk}

# Estimated indifference points from the calibration task ======================

# Filename
fn <- sprintf("ip_calibration_task-%s_dpi-%d", params$task, dpi)

# As raster image --------------------------------------------------------------
filename <- paste0(fn, ".png")
ggplot2::ggsave(path = figures_dir,
                filename = filename,
                plot = plt_ips_calibration,
                width = 8.5,
                units = "cm",
                dpi = dpi)

# Print filename, so it's clear from the static report where to find the file
print(sprintf("%s", file.path(figures_dir, filename)))

# As vector image --------------------------------------------------------------
filename <- paste0(fn, ".pdf")
ggplot2::ggsave(path = figures_dir,
                filename = filename,
                plot = plt_ips_calibration,
                width = 8.5,
                units = "cm",
                dpi = dpi)

# Print filename, so it's clear from the static report where to find the file
print(sprintf("%s", file.path(figures_dir, filename)))
```

```{r Write plot of proportion of LL choices across frames to disk}
# Filename
fn <- sprintf("plt_ll_choice_pctgs_task-%s_dpi-%d", params$task, dpi)

# As raster image --------------------------------------------------------------
filename <- paste0(fn, ".png")
ggplot2::ggsave(path = figures_dir,
                filename = filename,
                plot = plt_ll_choice_pctgs,
                width = 8.5,
                units = "cm",
                dpi = dpi)

# Print filename, so it's clear from the static report where to find the file
print(sprintf("%s", file.path(figures_dir, filename)))

# As vector image --------------------------------------------------------------
filename <- paste0(fn, ".pdf")
ggplot2::ggsave(path = figures_dir,
                filename = filename,
                plot = plt_ll_choice_pctgs,
                width = 8.5,
                units = "cm",
                dpi = dpi)

# Print filename, so it's clear from the static report where to find the file
print(sprintf("%s", file.path(figures_dir, filename)))
```

```{r Write plot of proportion of RT percentiles across frames to disk}
# Filename
fn <- sprintf("plt_rt_percentiles_task-%s_dpi-%d", params$task, dpi)

# As raster image --------------------------------------------------------------
filename <- paste0(fn, ".png")
ggplot2::ggsave(path = figures_dir,
                filename = filename,
                plot = plt_rt_percentiles,
                width = 8.5,
                units = "cm",
                dpi = dpi)

# Print filename, so it's clear from the static report where to find the file
print(sprintf("%s", file.path(figures_dir, filename)))

# As vector image --------------------------------------------------------------
filename <- paste0(fn, ".pdf")
ggplot2::ggsave(path = figures_dir,
                filename = filename,
                plot = plt_rt_percentiles,
                width = 8.5,
                units = "cm",
                dpi = dpi)

# Print filename, so it's clear from the static report where to find the file
print(sprintf("%s", file.path(figures_dir, filename)))
```

```{r Write plot of response time distributions to disk}
# Filename
fn <- sprintf("rt_density_ridges_task-%s_dpi-%d", params$task, dpi)

# As raster image --------------------------------------------------------------
filename <- paste0(fn, ".png")
ggplot2::ggsave(path = figures_dir,
                filename = filename,
                plot = plt_rt_density_ridges,
                width = 8.5,
                units = "cm",
                dpi = dpi)

# Print filename, so it's clear from the static report where to find the file
print(sprintf("%s", file.path(figures_dir, filename)))

# As vector image --------------------------------------------------------------
filename <- paste0(fn, ".pdf")
ggplot2::ggsave(path = figures_dir,
                filename = filename,
                plot = plt_rt_density_ridges,
                width = 8.5,
                units = "cm",
                dpi = dpi)

# Print filename, so it's clear from the static report where to find the file
print(sprintf("%s", file.path(figures_dir, filename)))
```

