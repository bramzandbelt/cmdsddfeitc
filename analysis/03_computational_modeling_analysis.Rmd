---
params:
  title: "03_computational_modeling_analysis"
  participant_id: 26 # identifier of participant in the study
  model_name: "DFT_C" # name of the model class to fit to the data
  parameterization: "value_scaling" # name of the parameterization to fit to the data
  bound_setting: "wide" # whether to use standard or wide bounds on parameter values
  algorithm: "DEoptimR"
  optimize: TRUE
  par_vals: !r c(0.95, 1, 1.05, 0.537, 1, 0.46, 10) # when optimize = FALSE, report is generated using these values
  max_iter: 2000 # maximum number of iterations
  rel_tol: 0.0001 # relative tolerance
  n_pop_per_free_param: 10
title: '`r stringr::str_c(stringr::str_to_title(params$title), " - participant ", params$participant_id)`'
subtitle: '`r stringr::str_c(stringr::str_to_upper(params$model_name), params$parameterization, stringr::str_c(params$bound_setting, " bounds"), sep = " - ")`'
author: "Bram Zandbelt"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_document:
    toc: true
    number_sections: true
    df_print: paged
    code_folding: hide
    theme: readable
    highlight: pygments
    bibliography: "cmdsddfeitc.bib"
    biblio-style: author-year
---

```{r setup, include=FALSE}
# Set root dir to project directory to ensure that code is always run relative to the project directory, no matter if it is run using `knitr` or interactively.
knitr::opts_knit$set(root.dir = rprojroot::find_root(rprojroot::has_file("DESCRIPTION")))

# Attach tideverse package to enable access to pipe (%>%)
require(tidyverse)
```

# Overview

This notebook performs __computational modeling__ of an individual participant's data. It takes as input a participant's cleaned and preprocessed experiment data and produces as output visualizations and csv files written to disk of optimization statistics, best-fitting model parameter values, model fit to the data, and predicted indifference point curves and area under the curve statistics.

# Preliminaries

Before reading the data the following is specified:

```{r Define notebook name, based on YAML header}
notebook_name <- 
   stringr::str_to_lower(stringr::str_replace_all(params$title, " ", "_"))
```
- the _name of the notebook (`notebook_name`)_, which is used to save output to a notebook-specific directory

```{r Define relevant directories for reading and writing data and create whenever needed}
# Raw trial log files are read from here
preprocessed_data_dir <- 
  file.path("data","derivatives", "01_preprocessing", "included")

# Model optimization data will be written here
optimizations_dir <- 
  file.path("data","derivatives", notebook_name)
converged_models_dir <- 
  file.path(optimizations_dir, "converged")
nonconverged_models_dir <- 
  file.path(optimizations_dir, "nonconverged")

# Create non-existing dirs if they don't exist
cmdsddfeitc::check_dir(all_dirs = c(preprocessed_data_dir, 
                                    optimizations_dir,
                                    converged_models_dir,
                                    nonconverged_models_dir))
```
- all _relevant directories_ for reading and writing data

```{r File name and task version}
# Determine which file should be read
expt_standard_trials_filename <- list.files(path = preprocessed_data_dir, 
                                            pattern = sprintf("^experiment_standard_trials_.*%.3d.csv$",
                                                              params$participant_id[[1]])
                                            )

# Determine task version, because factor levels (e.g. framing, trial_type) are task-dependent
task_version <- ifelse(stringr::str_detect(expt_standard_trials_filename, "defer_speedup"),
                    "defer_speedup",
                    ifelse(stringr::str_detect(expt_standard_trials_filename, "date_delay"),
                           "date_delay",
                           NA
                           )
                    )
```
- several variables relevant for modeling, including the _parameterization (`_parameterization`)_,  _framing levels (`framing_levels`)_, _parameter bounds (`lowers`, `uppers`)_, among others.

```{r Define some variables relevant for modeling}
# Parameterization & framing levels
parameterization <- 
  ifelse(params$parameterization == "one_condition",
         params$parameterization,
         stringr::str_c(task_version, "_", params$parameterization)
         )

if (task_version == "defer_speedup") {
  framing_levels <- c("neutral", "defer", "speedup")
} else if (task_version == "date_delay") {
  framing_levels <- c("delay", "date")
}

# Parameter bounds
lowers <- itchmodel::get_par_bounds(model = params$model_name,
                                    parameterization = parameterization,
                                    bound = 'lower',
                                    bound_setting = params$bound_setting)
uppers <- itchmodel::get_par_bounds(model = params$model_name,
                                    parameterization = parameterization,
                                    bound = 'upper',
                                    bound_setting = params$bound_setting)

# Number of free parameters
n_free_params <- sum(!(lowers == uppers))

# Parameter names
par_names <- itchmodel::get_par_names(model = params$model_name, parameterization = parameterization)
par_names <- factor(par_names, levels = par_names, ordered = TRUE)

free_par_names <- 
  par_names[!(lowers == uppers)]

free_par_lowers <- lowers[!(lowers == uppers)]
names(free_par_lowers) <- free_par_names
free_par_uppers <- uppers[!(lowers == uppers)]
names(free_par_uppers) <- free_par_names

# Tibble with bound values of free params
free_par_bounds_tibb <- 
  dplyr::bind_rows(free_par_lowers, free_par_uppers) %>% 
  dplyr::mutate(bound = c("lower", "upper")) %>% 
  dplyr::select(bound, dplyr::everything())

```

# Read data

Having specified all relevant variables, the cleaned standard trials from the experiment are read:
```{r Read trial_log data, warning=FALSE}
# Read (and print) the data, using task-dependent column specifications
(expt_trials <-
    readr::read_csv(file = file.path(preprocessed_data_dir, expt_standard_trials_filename),
                    col_types = cmdsddfeitc::get_col_types(stringr::str_c("expt_standard_trials_",
                                                                          task_version)))
  )

# Get rid of trials that won't be used
if (params$parameterization == "one_condition") {
  if (task_version == "defer_speedup") {
    frame_cond <- "neutral"
  } else if (task_version == "date_delay") {
    frame_cond <- "delay"
  }
  
  expt_trials <- 
    expt_trials %>% 
    dplyr::filter(frame == frame_cond) %>%
    dplyr::mutate(frame = forcats::fct_drop(.$frame))
    
}

# Number of data points
n_data_points <- nrow(expt_trials)
```

# Preprocess data

```{r Initialize a few key variables}

t_s <- unique(expt_trials$t_s)
t_ls <- sort(unique(expt_trials$t_l))
m_l <- unique(expt_trials$m_l)

m_s_min <- 0
m_s_max <- m_l
m_s_step <- 0.17

# Delays for which to compute AUC
delays_ip <- seq(0,max(t_ls),1)
```

## Prepare observed data for modeling

```{r Prepare observed data for modeling}
model_trials <- 
  expt_trials %>% 
  dplyr::mutate_if(is.numeric, round, 2) %>%
  dplyr::arrange(t_l, m_s) %>%
  dplyr::group_by(t_l) %>%
  dplyr::ungroup()

# Count the number of data points
n_data_points <- nrow(model_trials)


model_trials_grpd <- 
  model_trials %>%
  dplyr::group_by(frame)

stimuli <- 
  model_trials_grpd %>%
  dplyr::select(frame, m_s_cat, m_s, t_s, m_l, t_l) %>%
  tidyr::nest()

observations <- 
  model_trials_grpd %>%
  dplyr::select(frame, rt, response) %>%
  tidyr::nest()

model_trials_formatted <- 
dplyr::left_join(x = stimuli,
                 y = observations,
                 by = c("frame")
                 ) %>%
  dplyr::rename(stimuli = data.x,
                observations = data.y)

# Make sure that order of frames is correct, then convert to character (this is necessary)
(model_trials_formatted <- 
  model_trials_formatted %>%
  dplyr::arrange(frame) %>%
  dplyr::mutate(frame = as.character(frame))
)
```

## Prepare observed data for plotting
```{r Prepare observed data for plotting}
obs_for_plotting <- 
  expt_trials %>%
  dplyr::group_by(frame, t_l, m_s_cat) %>%
  dplyr::summarize(m_s = median(m_s),
                   p_ll = sum((response == "upper")) / n()) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(t_l = factor(t_l, 
                             levels = t_ls, 
                             labels = stringr::str_c(t_ls, " days"),
                             ordered = TRUE),
                m_s_cat = factor(m_s_cat,
                                 labels = c("below IP", "at IP", "above IP")))

print.data.frame(obs_for_plotting)
```

## Fit model to data
Here, the model parameterizations are fit to the choice and response time data, by minimizing negative log-likelihood using a differential evolution algorithm.

```{r Fit model to the data, warning=FALSE, results=FALSE}
# Set seed for the random number generator, so that results can be reproduced
set.seed(19821101) # That's my DOB

if (params$optimize) {
  
  if (params$algorithm == "DEoptim") {
    optim_out <- 
     DEoptim::DEoptim(fn = itchmodel::get_log_likelihood, # optimization function
                      lower = lowers, # lower bounds
                      upper = uppers, # upper bounds
                      control = list(itermax = params$max_iter, 
                                     reltol = params$rel_tol,
                                     NP = params$n_pop_per_free_param * n_free_params,
                                     trace = TRUE
                                     ),
                      # Additional arguments passed to fn and constr:
                      data = model_trials_formatted,
                      model = params$model_name,
                      parameterization = parameterization
                      )
    
  } else if (params$algorithm == "DEoptimR") {
    optim_val <- rep(NA, params$max_iter)
    pars_per_iter <- matrix(nrow = params$max_iter, ncol = length(lowers))
    colnames(pars_per_iter) <- par_names
    
    this_optim_val <- 1e6
    iter <- 1
    
    # constr <- itchmodel::get_nonlinear_constraints, # nonlinear constraints
    # constr <- NULL
    
    while (this_optim_val >= 1e6) {
      optim_out <-
        DEoptimR::JDEoptim(fn = itchmodel::get_log_likelihood, # optimization function
                           lower = lowers, # lower bounds
                           upper = uppers, # upper bounds
                           constr = itchmodel::get_nonlinear_constraints,
                           meq = 0,
                           maxiter = 1,
                           tol = params$rel_tol,
                           NP = params$n_pop_per_free_param * n_free_params,
                           trace = TRUE,
                           details = TRUE,
                           # Additional arguments passed to fn and constr:
                           data = model_trials_formatted,
                           model = params$model_name,
                           parameterization = parameterization,
                           pcrit = c(.95, .05)
                           )
      
      this_optim_val <- optim_out$value
      optim_val[iter] <- optim_out$value
      pars_per_iter[iter,] <- optim_out$par
    }
    
    # Do remaining iterations
    while (optim_out$convergence == 1 & iter <= (params$max_iter - 1)) {
      
      iter <- iter + 1
      
      optim_out <- 
       DEoptimR::JDEoptim(fn = itchmodel::get_log_likelihood, # optimization function
                          lower = lowers, # lower bounds
                          upper = uppers, # upper bounds
                          meq = 0,
                          constr = itchmodel::get_nonlinear_constraints,
                          maxiter = 1,
                          tol = params$rel_tol,
                          NP = 0,
                          add_to_init_pop = optim_out$poppar,
                          trace = TRUE,
                          details = TRUE,
                          # Additional arguments passed to fn and constr:
                          data = model_trials_formatted,
                          model = params$model_name,
                          parameterization = parameterization,
                          pcrit = c(.95, .05)
                        )
      
      optim_val[iter] <- optim_out$value
      pars_per_iter[iter,] <- optim_out$par
      
      free_par_vals_per_iter_tibb <- 
        tibble::as.tibble(na.exclude(pars_per_iter)) %>% 
        dplyr::mutate(iter = 1:n()) %>% 
        dplyr::select(iter, as.character(free_par_names)) %>%
        tidyr::gather(key = "key",
                      value = "value",
                      as.character(free_par_names),
                      factor_key = TRUE)
    }
  }
} else {
  
  val <- 
      itchmodel::get_log_likelihood(x = params$par_vals,
                                    data = model_trials_formatted,
                                    model = params$model_name,
                                    parameterization = parameterization)
  
  if (params$algorithm == "DEoptim") {
    
    optim_out <- 
      list(member = list(bestvalit = val,
                         bestmemit = matrix(params$par_vals, 
                                            nrow = 1, 
                                            dimnames = list(1,
                                                            stringr::str_c("par", seq(1,8)))),
                         bestmem = params$par_vals),
           optim = list(bestval = val,
                        iter = 1))
    
  } else if (params$algorithm == "DEoptimR") {
    
    optim_out <- 
      list(value = val,
           par = params$par_vals,
           iter = 1,
           convergence = FALSE)
    
    iter <- 1
    optim_val <- rep(NA, iter)
    pars_per_iter <- matrix(nrow = iter, ncol = length(lowers))
    colnames(pars_per_iter) <- par_names
    
    optim_val[1] <- optim_out$value
    pars_per_iter[1,] <- optim_out$par
    
    free_par_vals_per_iter_tibb <- 
        tibble::as.tibble(na.exclude(pars_per_iter)) %>% 
        dplyr::mutate(iter = 1:n()) %>% 
        dplyr::select(iter, as.character(free_par_names)) %>%
        tidyr::gather(key = "key",
                      value = "value",
                      as.character(free_par_names),
                      factor_key = TRUE)
  
  }
  
}

```


```{r Save log-likelihood and best fitting parameter values to variables }
if (params$algorithm == "DEoptim") {
  optim_val <- optim_out$member$bestvalit
  pars_per_iter <- optim_out$member$bestmemit
  best_pars <- unname(optim_out$optim$bestmem)
} else if (params$algorithm == "DEoptimR") {
  optim_val[iter] <- optim_out$value
  pars_per_iter[iter,] <- optim_out$par
  best_pars <- optim_out$par
}

# Store best-fitting parameter values per frame in a variable for later use
best_pars_per_frame <- 
    itchmodel::get_par_values(x = best_pars, 
                              model = params$model_name, 
                              parameterization = parameterization)
  if (!is.list(best_pars_per_frame)) {
    best_pars_per_frame <- list(best_pars_per_frame)
  }
```

## Make model predictions based on best-fitting parameters

```{r Make model predictions based on best-fitting parameters}
prds <- 
  tidyr::crossing(frame = factor(levels = itchmodel::get_frames(parameterization = parameterization), ordered = TRUE),
                  t_l = t_ls,
                  t_s = t_s,
                  m_l = m_l,
                  m_s = seq(m_s_min, m_s_max, m_s_step)) %>%
  dplyr::group_by(frame) %>%
  tidyr::nest(.key = "stimuli") %>%
  dplyr::mutate(params = best_pars_per_frame) %>%
  dplyr::mutate(du = purrr::pmap(.l = list(parameters = .$params,
                                           stimuli = .$stimuli,
                                           frame = as.character(.$frame)),
                                 .f = itchmodel::compute_transformation_diffs,
                                 parameterization = parameterization,
                                 variable = "du"),
                dp = purrr::pmap(.l = list(parameters = .$params,
                                           stimuli = .$stimuli,
                                           frame = as.character(.$frame)),
                                 .f = itchmodel::compute_transformation_diffs,
                                 parameterization = parameterization,
                                 variable = "dp")) %>%
  dplyr::mutate(d = purrr::pmap(.l = list(params = .$params, 
                                          du = .$du, 
                                          dp = .$dp),
                                .f = function(params, du, dp) {unname(params["w"] * du - (1 - params["w"]) * dp)}),
                d_test = purrr::pmap(.l = list(parameters = .$params,
                                           stimuli = .$stimuli,
                                           frame = as.character(.$frame)),
                                .f = itchmodel::compute_drift_rate,
                                parameterization = parameterization)
                )
                
if (params$model_name %in% c("DFT_C", "DFT_CRT")) {
  prds <- 
    prds %>%
    dplyr::mutate(s = purrr::pmap(.l = list(x = .$params,
                                           du = .$du,
                                           dp = .$dp,
                                           d = .$d),
                                  .f = function(x, du, dp, d){
                                    unname(sqrt(x["w"] * du^2 + (1 - x["w"]) * dp^2 - d^2))}
                                  )
                  ) %>%
    dplyr::mutate(p_ll = purrr::pmap(.l = list(d = .$d,
                                               s = .$s,
                                               params = .$params),
                                     .f = function(d, s, params) {
                                       theta_star <- unname(params["theta_star"])
                                       
                                       itchmodel::dft_cp(d = d,
                                                         s = s,
                                                         theta = theta_star * s,
                                                         z = rep(0,length(d)),
                                                         response = rep("upper",length(d)))}
                                   )
                  )
    
  
} else if (params$model_name == "DDM") {
  prds <- 
    prds %>%
    dplyr::mutate(p_ll = purrr::pmap(.l = list(d = .$d,
                                               params = .$params),
                                     .f = function(d, s, params) {
                                       itchmodel::db_bin_choice_prob(d = d, 
                                                                     s = rep(1,length(d)),
                                                                     a = rep(unname(params["a"]), length(d)), 
                                                                     z = rep(0,length(d)))}
                                   )
                  )
  
}

print.data.frame(prds)
```

## Prepare predicted data for plotting

```{r Prepare predicted data for plotting}
prds_for_plot <- 
  prds %>% 
  dplyr::select(frame, stimuli, p_ll) %>% 
  tidyr::unnest() %>%
  dplyr::mutate(t_l = factor(t_l, 
                             levels = c(2,4,8,16,32,64,128),
                             labels = c("2 days", "4 days", "8 days", "16 days",
                                        "32 days", "64 days", "128 days"),
                             ordered = TRUE))

print.data.frame(prds_for_plot)
```

## Determine indifference points based on model fits

```{r Determine indifference points based on model fits}
# Determine indifference points, given LL amount, LL delay, and best-fitting parameters
predict_ip <- function(m_l, t_l, parameters, frame) {
  
  
  if (frame == 'defer') {
    numerator_lh <- unname(parameters["w"] * 1 * m_l^parameters["alpha"])
  } else {
    numerator_lh <- unname(parameters["w"] * parameters["mu"] * m_l^parameters["alpha"])
  }
  
  numerator_rh <- unname((1 - parameters["w"]) * parameters["kappa"] * t_l^parameters["beta"])
  numerator <- numerator_lh - numerator_rh
  
  if (frame == 'speedup') {
    denominator <- unname(parameters["w"] * 1)
  } else {
    denominator <- unname(parameters["w"] * parameters["mu"])
  }
  
  frac <- numerator/denominator
  frac[frac < 0] <- 0
  
  return(10^(log10(frac)/unname(parameters["alpha"])))
  
}

```


## Determine area under the curve based on model fits

```{r Determine area under the curve based on model fits}
prds <- 
  prds %>%
  dplyr::mutate(ip = purrr::pmap(.l = list(parameters = .$params,
                                           frame = as.character(.$frame)),
                                 .f = predict_ip,
                                 m_l = m_l,
                                 t_l = delays_ip)) %>%
  dplyr::mutate(auc = purrr::pmap(.l = list(y = .$ip),
                                  .f = DescTools::AUC,
                                  x = delays_ip,
                                  method = "trapezoid"))
```

## Select indifference point data for plotting

```{r Select indifference point data for plotting}
prd_ip_data <- 
  prds %>%
  dplyr::select(frame, ip) %>%
  tidyr::unnest() %>%
  dplyr::mutate(delay = rep(delays_ip, nrow(prds)))

print.data.frame(prd_ip_data)
```

# Visualize data

## Optimization process

### Optimization descriptives

```{r Print optimization statistics}
optim_stats <- 
  itchmodel::get_fit_stats(optim_output = optim_out, 
                           algorithm = params$algorithm,
                           model = params$model_name, 
                           parameterization = parameterization, 
                           n_data_points = n_data_points)

# n_iter in optim_out does not reflect the actual number of iterations, because we do iterations in a loop
optim_stats$n_iter = iter

print.data.frame(optim_stats)
```

### Best-fitting parameters values and lower and upper bounds

```{r Print best-fitting parameter values}
best_fitting_par_values <- 
  tibble(frame = factor(itchmodel::get_frames(parameterization = parameterization), ordered = TRUE),
         params = itchmodel::get_par_values(x = best_pars, 
                                            model = params$model_name, 
                                            parameterization = parameterization)
         ) %>%
  dplyr::mutate(r = purrr::map(params, ~ data.frame(t(.)))) %>%
  tidyr::unnest(r) %>%
  dplyr::select(-params)

print.data.frame(best_fitting_par_values)
print.data.frame(free_par_bounds_tibb)
```

### Evolution of parameter values over iterations
How did values of free model parameters evolve over iterations?
Did the model optimzation routine converge?
Do best-fitting parameter values end up at bounds


```{r Evolution of parameter values over iterations, out.width="100%"}
h_line_data <- 
  free_par_bounds_tibb %>%
  tidyr::gather(key = "key", value = "value", -bound) %>% 
  tidyr::spread(key = bound, value = value)


ggplot2::ggplot(free_par_vals_per_iter_tibb,
                ggplot2::aes(x = iter,
                             y = value)) +
  ggplot2::facet_wrap("key",
                      scales = "free_y") +
  ggplot2::geom_hline(data = h_line_data,
                      ggplot2::aes(yintercept = lower),
                      color = "red") +
  ggplot2::geom_hline(data = h_line_data,
                      ggplot2::aes(yintercept = upper),
                      color = "red") +
  
  ggplot2::geom_line() +
  cmdsddfeitc::theme_cmfsddfeitc()
```


## Model fit to the data

```{r Model fit to the data, , out.width="100%"}
ggplot2::ggplot(data = prds_for_plot,
                ggplot2::aes(x = m_s,
                             y = p_ll, 
                             group = frame,
                             color = frame)) +
  ggplot2::facet_wrap("t_l") +
  ggplot2::geom_line() + 
  ggplot2::geom_point(data = obs_for_plotting,
                      ggplot2::aes(x = m_s,
                                   y = p_ll,
                                   color = frame,
                                   shape = m_s_cat),
                      stroke = 1.5) +
  ggplot2::scale_x_continuous(name = "Smaller sooner amount (€)",
                              breaks = c(0, 20, 40),
                              limits = c(0,43.52)
                              ) +
  ggplot2::scale_y_continuous(name = "P(choosing LL)",
                              breaks = seq(0,1,0.5),
                              limits = c(0,1)) +
  ggplot2::scale_shape_manual(name = "SS amount category",
                              values = c(6,1,2)) +
  ggplot2::scale_color_manual(values = cmdsddfeitc::get_aes_values("color", parameterization)) +
  cmdsddfeitc::theme_cmfsddfeitc() + 
  ggplot2::theme(legend.position = "bottom",
                 legend.direction = "vertical", 
                 legend.box = "horizontal")
```

```{r Model fit to the data as t_l by frame grid, , out.width="100%"}
ggplot2::ggplot(data = prds_for_plot,
                ggplot2::aes(x = m_s,
                             y = p_ll, 
                             color = frame)) +
  # ggplot2::facet_grid(t_l ~ frame) +
  ggplot2::facet_grid(frame ~ t_l) +
  ggplot2::geom_line() + 
  ggplot2::geom_point(data = obs_for_plotting,
                      ggplot2::aes(x = m_s,
                                   y = p_ll,
                                   color = frame,
                                   shape = m_s_cat),
                      stroke = 1) +
  ggplot2::scale_x_continuous(name = "Smaller sooner amount (€)",
                              breaks = c(0, 20, 40),
                              limits = c(0,43.52)
                              ) +
  ggplot2::scale_y_continuous(name = "P(choosing LL)",
                              breaks = seq(0,1,0.5),
                              limits = c(0,1)) +
  ggplot2::scale_shape_manual(name = "SS amount category",
                              values = c(6,1,2)) +
  ggplot2::scale_color_manual(values = cmdsddfeitc::get_aes_values("color", parameterization)) +
  cmdsddfeitc::theme_cmfsddfeitc() + 
  ggplot2::theme(legend.position = "bottom",
                 legend.direction = "vertical", 
                 legend.box = "horizontal")
  # ggplot2::theme(legend.position = "right")

```





## Indifference point by delay curves

```{r Indifference point by delay curves, out.width="100%"}
ggplot2::ggplot(prd_ip_data,
                ggplot2::aes(x = delay,
                             y = ip, 
                             color = frame)) + 
  ggplot2::geom_line() + 
  
  ggplot2::scale_color_manual(values = cmdsddfeitc::get_aes_values("color", parameterization)) +
  ggplot2::scale_x_continuous(name = "Delay (days)",
                              limits = c(0, max(t_ls))) +
  ggplot2::scale_y_continuous(name = "Indifference point (€)",
                              limits = c(0, m_l)) +
  cmdsddfeitc::theme_cmfsddfeitc()
```

# Write data

The directory in which the computational modeling data will be written depends on whether the model optimization procedure converged (`optimization_converged`) or not (`optimization_nonconverged`).

```{r Write data to disk only if model is optimized}

if (params$optimize) {
  
  # Define output directory based on whether all performance criteria were met
  
  data_output_dir <- 
    ifelse(optim_stats$converged,
           converged_models_dir,
           nonconverged_models_dir
           )
  
  # Write best-fitting model parameters to disk --------------------------------
  
  # Add relevant variables, so that these files can be read and combined into a 
  # larger data frame for additional analysis
  par_vals <- optim_out$par
  names(par_vals) <- par_names
  
  par_vals_output <-
    dplyr::bind_rows(par_vals) %>%
    dplyr::mutate(participant_id = params$participant_id,
                  model_name = params$model_name,
                  parameterization = params$parameterization,
                  bound_settings = params$bound_setting) %>%
    dplyr::select(participant_id, model_name, parameterization, bound_settings, dplyr::everything())
  
  # Make file name human- and machine-readable, so that main results can be read from file name
  par_vals_file <-
    file.path(data_output_dir,
              sprintf("best_fitting_params_task-%s_pid-%.3d_model-%s_pmz-%s_bounds-%s_BIC-%.0f.csv",
                      task_version,
                      params$participant_id, # pid
                      params$model_name, # mode
                      params$parameterization, # pmz
                      params$bound_setting, # bounds
                      optim_stats$BIC # BIC
                      )
              )
  
  readr::write_csv(par_vals_output,
                   path = par_vals_file
              )
  print(sprintf("Best-fitting model parameters: %s", par_vals_file))
  
  # Write optimization statistics to disk --------------------------------------
  
  # Add relevant variables, so that these files can be read and combined into a 
  # larger data frame for additional analysis
  optim_stats_output <-
    optim_stats %>%
    dplyr::mutate(participant_id = params$participant_id,
                  bound_settings = params$bound_setting) %>%
    dplyr::select(participant_id, model, parameterization, bound_settings, dplyr::everything())
  
  
  # Make file name human- and machine-readable, so that main results can be read from file name
  optim_stats_file <-
    file.path(data_output_dir,
              sprintf("optim_stats_task-%s_pid-%.3d_model-%s_pmz-%s_bounds-%s_BIC-%.0f.csv",
                      task_version,
                      params$participant_id, # pid
                      params$model_name, # mode
                      params$parameterization, # pmz
                      params$bound_setting, # bounds
                      optim_stats$BIC # BIC
                      )
              )
  
  # Save to disk
  readr::write_csv(optim_stats_output,
                   path = optim_stats_file
              )
  print(sprintf("Optimization statistics: %s", optim_stats_file))
  
  # Write predicted IP data to disk --------------------------------------------
  
  # Add relevant variables, so that these files can be read and combined into a 
  # larger data frame for additional analysis
  prd_ip_output <-
    prd_ip_data %>%
    dplyr::mutate(participant_id = params$participant_id,
                  bound_settings = params$bound_setting,
                  model = params$model_name,
                  parameterization = params$parameterization) %>%
    dplyr::select(participant_id, model, parameterization, bound_settings, dplyr::everything())
  
  
  # Make file name human- and machine-readable, so that main results can be read from file name
  prd_ip_output_file <-
    file.path(data_output_dir,
              sprintf("predicted_indifference_points_task-%s_pid-%.3d_model-%s_pmz-%s_bounds-%s_BIC-%.0f.csv",
                      task_version,
                      params$participant_id, # pid
                      params$model_name, # mode
                      params$parameterization, # pmz
                      params$bound_setting, # bounds
                      optim_stats$BIC # BIC
                      )
              )
  
  # Save to disk
  readr::write_csv(prd_ip_output,
                   path = prd_ip_output_file
              )
  print(sprintf("Indifference point data: %s", prd_ip_output_file))
  
  # Write area under the curve to disk -----------------------------------------
  
  # Add relevant variables, so that these files can be read and combined into a 
  # larger data frame for additional analysis
  auc_output <-
    prds %>%
    dplyr::select(frame, auc) %>%
    tidyr::unnest() %>%
    dplyr::mutate(participant_id = params$participant_id,
                  bound_settings = params$bound_setting,
                  model = params$model_name,
                  parameterization = params$parameterization) %>%
    dplyr::select(participant_id, model, parameterization, bound_settings, dplyr::everything())
  
  
  # Make file name human- and machine-readable, so that main results can be read from file name
  auc_output_file <-
    file.path(data_output_dir,
              sprintf("auc_task-%s_pid-%.3d_model-%s_pmz-%s_bounds-%s_BIC-%.0f.csv",
                      task_version,
                      params$participant_id, # pid
                      params$model_name, # mode
                      params$parameterization, # pmz
                      params$bound_setting, # bounds
                      optim_stats$BIC # BIC
                      )
              )
  
  # Save to disk
  readr::write_csv(auc_output,
                   path = auc_output_file
              )
  print(sprintf("Area under the curve: %s", auc_output_file))
}



```
